# WPT Paramter Search 2

## 概要

### 一般論：多変数関数の逆問題

いくつかの変数をもつ関数$f$が具体的な形で与えられているとする。
$$y=f(x_1, x_2, x_3, \ldots )=x_1^2 + x_2 x_3 + \cdots$$
変数が具体的な値をもつとき，関数の値がどうなるかは単純に代入するだけで答えがわかる。
$$y=f(2,1,\tfrac{3}{7},\ldots )=2^2 + 1\cdot \tfrac{3}{7} + \cdots$$
しかし逆に，関数が指定した値をとるのは，変数がどのような値をもつときなのかを知ることは難しく，可能かどうかも一般にはわからない。
$$\tfrac{1}{2} = f(x_1, x_2, x_3, \ldots )=x_1^2 + x_2 x_3 + \cdots
\quad \Rightarrow \quad
x_1=?,\ x_2=?,\ x_3=?,\ldots$$

### WPTにおける逆問題

![wpt ss C1 C2](fig/wptSSC1C2.drawio.png)

無線電力伝送の標準的な回路において，負荷が受け取る平均電力$P$は次のように表される。
$$P=\frac{R_{L} V_{S}^{2}}{8 R_{1} R_{2}}P_N$$
$$P_N=\frac{4 k^{2} R_{1} R_{2} L_{1} L_{2} \omega^{2}}{\left(R_{1} R_{2} + \left(\omega L_{1} - \frac{1}{\omega C_{1}}\right)\left(\omega L_{2} - \frac{1}{\omega C_{2}}\right) - \omega^{2} k^{2} L_{1} L_{2}\right)^{2} + \left(R_{1}\left(\omega L_{2} - \frac{1}{\omega C_{2}}\right) - R_{2}\left(\omega L_{1} - \frac{1}{\omega C_{1}}\right)\right)^{2} + 4 k^{2} R_{1} R_{2} L_{1} L_{2} \omega^{2}}$$
ただし，$V_S$は理想電圧源の電圧の振幅であり，$R_1=R_S+R_{p1}$, $R_2=R_L+R_{p2}$とおいた。$R_S$などの素子の定数，角周波数$\omega$はすべて正の実数である。また結合係数$k$は$0 < k^2 < 1$を満たす値をとりうる。このとき，$P_N$は必ず$0 < P_N \leqq 1$の値をとる。この$P_N$を正規化電力という。$P_N$は
$$R_1,R_2,L_1,L_2,C_1,C_2,k,\omega$$
を変数とする８変数関数である。
負荷が受け取る平均電力を大きくしたい，つまりたとえば

- $0.9\leqq P_N\leqq 1$

となるような変数の値を知りたい。

### 現実的制約（部品・周波数など）

現実的には，

- 使用する電源は決まっていて内部抵抗をすでに求めている
- 電源が出すことのできる正弦波交流電圧の周波数$f$には限界がある
- 負荷の抵抗値は手元にあるものを直並列接続で作りたい
- コイルはすでに巻きおわっていて，それを利用したい
- コンデンサは在庫の中から選びたい

など，得たい電力以外の希望があるだろう。そこで解きたい問題は，$0.9\leqq P_N\leqq 1$だけでなく，次のような条件を満たす変数の値を知りたいということになる。

- $R_1=1.0$ $\Omega$
- $10.0$ kHz $\leqq f = \tfrac{\omega}{2\pi} \leqq$ $100.0$ kHz
- $R_2=10.0$ $\Omega$
- $L_1=140.0$ $\mu$ H
- $L_2=130.0$ $\mu$ H
- $1.0$ nF $\leqq C_1 \leqq$ $100.0$ nF
- $1.0$ nF $\leqq C_2 \leqq$ $100.0$ nF

### 探索

問題の答えを見つける最も単純な方法は，各変数について与えられた範囲から値を選び，関数に代入し，その結果が指定した範囲に入るかどうかを判定することである。この操作を多数回繰り返せば，条件を満たす解が得られる可能性がある。

しかし，いくら繰り返しても正解に到達できない場合もある。これは，そもそも解が存在しない場合と，繰り返し回数が不足している場合のいずれかである。どちらに該当するかを事前に判別することは，無線電力伝送の平均電力の式のような複雑な関数では一般に困難である。

そこで本プログラムでは，「変数の値を選び，代入し，判定する」という操作をあらかじめ定めた回数だけ実行し，その結果をもとに探索範囲の妥当性を判断する。正解が得られた場合は目的を達成したとし，得られなかった場合は範囲を再設定して再計算を行う。

この方法では繰り返し回数をできるだけ多くしたいが，解が存在しない場合も考慮すると，正解の有無にかかわらず短時間で結果を得ることが重要となる。そのため，本プログラムの実装には Go 言語を用いた。四則演算や条件判定といった基本的な処理の実行速度は C 言語と同等であり，体感的にはコンパイル済み Python の約 10 倍，通常の Python や Wolfram の約 100 倍の速度で動作する。

## コード

### GOのコードを編集するときの注意

- GOには非常に厳しい文法チェックがあり，pythonのようにはいかない。
- `Visual Studio Code`エディターにGO拡張を追加しておくと，文法チェックが直ちに入り，間違いがあれば指摘される。
- 動かない場合はコードをchatGPTに貼り付けて，状況を伝えると大抵は修正できる。

### ユーザーがコード中に記述（`config.go`）

- 関数の具体的定義式とその引数
- 各引数について，引数の値の範囲
- 各引数について，引数の値の範囲から値を線形的な分点で選ぶのか，対数的な分点で選ぶのかの別
- 関数の値の範囲
- 繰り返し回数
- 引数の値，関数の値のどれもが指定した範囲に入ったときの引数と関数の値（正解）
- 保存する正解の数
- 引数の値，関数の値のどれかが指定した範囲に入らなかったときの引数と関数の値（不正解）
- 保存する不正解の数
- エクセルファイルに保存したい場合はファイル名を指定
- tsv形式のファイルに保存したい場合はファイル名を指定（正解，不正解それぞれ）

引数の範囲については以下で設定する。
```go
	params := []ParamSpec{
		{Name: "k", Min: 0.01, Max: 0.02, Scale: Linear},
		{Name: "f", Min: 10_000, Max: 100_000, Scale: Log}, // Hz
		{Name: "R1", Min: 1.0, Max: 1.0, Scale: Log},       // Ω
		{Name: "R2", Min: 10.0, Max: 10.0, Scale: Log},     // Ω
		{Name: "L1", Min: 140e-6, Max: 140e-6, Scale: Log}, // H
		{Name: "L2", Min: 80e-6, Max: 80e-6, Scale: Log},   // H
		{Name: "C1", Min: 1e-9, Max: 100e-9, Scale: Log},   // F
		{Name: "C2", Min: 1e-9, Max: 100e-9, Scale: Log},   // F
	}
	// 関数の値の範囲。計算結果がこの範囲に入っていれば正解，入っていなければ不正解
	yRange := Range{Min: 0.3, Max: 1.0}

	// 繰り返し回数（10_000_000 で数秒）
	maxIters := int64(1_000_000)

	// 保存する正解・不正解の数（多くするとファイルサイズ増）
	maxOKSave := 10
	maxNGSave := 10

	// 進行状況表示の更新間隔（多すぎると遅くなる）
	printEvery := int64(200_000)

	// 乱数 seed（実行時刻ベース）
	// seedを自分で決めてもよい。
	// 実行すると乱数発生に使用されたseedが表示されるので，そのときと同じ数字を使うと
	// 同じ乱数が発生するので，結果も同じになる。
	seed := time.Now().UnixNano()
	// seed = 1771036496700922400

	// xlsx 出力（空文字なら保存しない）
	// "" にすると保存はせず表示だけ
	xlsxFile := "result.xlsx"
	xlsxFile = ""

	// tsv 出力（"" なら保存しない）
	okTSVFile := "ok.tsv"
	okTSVFile = ""
	ngTSVFile := "ng.tsv"
	ngTSVFile = ""
```

### 出力（コンソール表示）（`output.go`）

- 保存した正解リスト
- 保存した不正解リスト
- Ctrl-Cで終了した場合はその時点における保存した正解リスト，不正解リスト（思ったより時間がかかってしまった場合や，とりあえず繰り返し回数を多くしておいてその時点までの結果を知りたいとき）
- エクセルファイル（ファイル名を指定した場合）
- tsv形式のファイル（ファイル名を指定した場合）

### 終了条件

- 繰り返し回数に到達
- Ctrl-C

### アルゴリズム

以下を終了条件を満たすまで繰り返す。進行状況確認用に正解数，不正解数カウンターを表示

- 線形分点指定の引数については，範囲中から線形的に一様乱数によって値を選ぶ
- 対数分点指定の引数については，範囲中から対数的に一様乱数によって値を選ぶ
- 選んだ引数の値で関数の値を計算
- 関数の値が範囲に入っていれば正解リストに追加。
- 関数の値が範囲に入っていなければ不正解リストに追加

### 実行方法

- `git`をインストールしておく
- `go`言語をインストールしておく
- コマンドプロンプトやpowershellで`git clone https://github.com/ichijohodaka/wpt-parameter-search2.git`
- `wpt-parameter-search2`フォルダに`cd`して，`go run .`
- 「ユーザー設定（ここから）」から「ユーザー設定（ここまで）」の間のコードを適宜書き換え
- ユーザーが関数を変更して使うことを想定しているので、buildせずにコードを直接修正して実行

## 使用例

### 実験装置の製作時

- そこそこ電力が出るような実験装置を作りたい。
- 電源は決まっている。
- コイルもある。

このような場合は、R1, R2, L1, L2のMinとMaxを決まっている値に一致させ、範囲を狭くしたほうが探索が成功しやすい。

```go
	params := []ParamSpec{
		{Name: "k", Min: 0.01, Max: 0.02, Scale: Linear},
		{Name: "f", Min: 10_000, Max: 100_000, Scale: Log}, // Hz
		{Name: "R1", Min: 1.0, Max: 1.0, Scale: Log},       // Ω
		{Name: "R2", Min: 10.0, Max: 10.0, Scale: Log},     // Ω
		{Name: "L1", Min: 140e-6, Max: 140e-6, Scale: Log}, // H
		{Name: "L2", Min: 80e-6, Max: 80e-6, Scale: Log},   // H
		{Name: "C1", Min: 1e-9, Max: 100e-9, Scale: Log},   // F
		{Name: "C2", Min: 1e-9, Max: 100e-9, Scale: Log},   // F
	}
```

### 電力が指定した範囲に入るようなパラメータの領域を視覚化

- R1, R2, L1, L2, C1, C2は決まった値を用いる。
- 正規化電力が0.1以上，0.2以下になるようなkとfの領域をみたい。
- はじめはいろいろ試したいので，下記のようにしてファイル保存しない。

```go
	params := []ParamSpec{
		{Name: "k", Min: 0.0, Max: 1.0, Scale: Linear},
		{Name: "f", Min: 10_000, Max: 100_000, Scale: Log},   // Hz
		{Name: "R1", Min: 1.0, Max: 1.0, Scale: Log},         // Ω
		{Name: "R2", Min: 10.0, Max: 10.0, Scale: Log},       // Ω
		{Name: "L1", Min: 140e-6, Max: 140e-6, Scale: Log},   // H
		{Name: "L2", Min: 80e-6, Max: 80e-6, Scale: Log},     // H
		{Name: "C1", Min: 90 * 1e-9, Max: 90e-9, Scale: Log}, // F
		{Name: "C2", Min: 90 * 1e-9, Max: 90e-9, Scale: Log}, // F
	}
	// 関数の値の範囲。計算結果がこの範囲に入っていれば正解，入っていなければ不正解
	yRange := Range{Min: 0.1, Max: 0.2}

	// 繰り返し回数（10_000_000 で数秒）
	maxIters := int64(1_000_000)

	// 保存する正解・不正解の数（多くするとファイルサイズ増）
	maxOKSave := 10
	maxNGSave := 10

	// 進行状況表示の更新間隔（多すぎると遅くなる）
	printEvery := int64(200_000)

	// 乱数 seed（実行時刻ベース）
	// seedを自分で決めてもよい。
	// 実行すると乱数発生に使用されたseedが表示されるので，そのときと同じ数字を使うと
	// 同じ乱数が発生するので，結果も同じになる。
	seed := time.Now().UnixNano()
	// seed = 1771034207274033700

	// xlsx 出力（空文字なら保存しない）
	// "" にすると保存はせず表示だけ
	xlsxFile := "result.xlsx"
	xlsxFile = ""

	// tsv 出力（"" なら保存しない）
	okTSVFile := "ok.tsv"
	okTSVFile = ""
	ngTSVFile := "ng.tsv"
	ngTSVFile = ""
```

この条件で実行したところ、次の結果を得た。

```bash
iter=     1000000 (100.00%)  OK_hits=       69036  NG_hits=      930964
iter=     1000000 (100.00%)  OK_hits=       69036  NG_hits=      930964
seed=1771036496700922400
yRange=[       0.1,        0.2]
iters=1000000  OK_hits=69036  NG_hits=930964
OK_ratio=   0.06904  NG_ratio=     0.931
```

OK_hitsの数がそこそこ大きいので領域をうまく表せそうである。そこでそのデータを保存する。データ数が大きくなりそうなので、むやみに保存すべきでない。ng.tsvのほうはいらないだろう。さきほどのseedを用いると同じ結果になる。OKの数もわかっているので、保存する数を一致させる。

保存した結果を視覚化してみよう。ここでは`gnuplot`を用いた例を示す。次を`regionOK.gp`のように拡張子`gp`を付けて`ok.tsv`と同じフォルダに保存し，`.\regionOK.gp`で実行すると，`scatter.png`ができる。

```gnuplot
set datafile separator "\t"

set key autotitle columnhead

set terminal pngcairo size 900,600 enhanced font "Arial,12"
set output "scatter.png"

set xlabel "f"
set ylabel "k"

set logscale x 10
set format x "10^{%L}"
set mxtics 10

set grid

plot "ok.tsv" using "f":"k" with points pt 7 ps 0.6 notitle
```

![scatter plot](scatter.png)



