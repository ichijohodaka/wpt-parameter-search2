# WPT Paramter Search 2

## 概要

### 一般論：多変数関数の逆問題

いくつかの変数をもつ関数$f$が具体的な形で与えられているとする。
$$y=f(x_1, x_2, x_3, \ldots )=x_1^2 + x_2 x_3 + \cdots$$
変数が具体的な値をもつとき，関数の値がどうなるかは単純に代入するだけで答えがわかる。
$$y=f(2,1,\tfrac{3}{7},\ldots )=2^2 + 1\cdot \tfrac{3}{7} + \cdots$$
しかし逆に，関数が指定した値をとるのは，変数がどのような値をもつときなのかを知ることは難しく，可能かどうかも一般にはわからない。
$$\tfrac{1}{2} = f(x_1, x_2, x_3, \ldots )=x_1^2 + x_2 x_3 + \cdots
\quad \Rightarrow \quad
x_1=?,\ x_2=?,\ x_3=?,\ldots$$

### WPTにおける逆問題

![wpt ss C1 C2](fig/wptSSC1C2.drawio.png)

無線電力伝送の標準的な回路において，負荷が受け取る平均電力$P$は次のように表される。
$$P=\frac{R_{L} V_{S}^{2}}{8 R_{1} R_{2}}P_N$$
$$P_N=\frac{4 k^{2} R_{1} R_{2} L_{1} L_{2} \omega^{2}}{\left(R_{1} R_{2} + \left(\omega L_{1} - \frac{1}{\omega C_{1}}\right)\left(\omega L_{2} - \frac{1}{\omega C_{2}}\right) - \omega^{2} k^{2} L_{1} L_{2}\right)^{2} + \left(R_{1}\left(\omega L_{2} - \frac{1}{\omega C_{2}}\right) - R_{2}\left(\omega L_{1} - \frac{1}{\omega C_{1}}\right)\right)^{2} + 4 k^{2} R_{1} R_{2} L_{1} L_{2} \omega^{2}}$$
ただし，$V_S$は理想電圧源の電圧の振幅であり，$R_1=R_S+R_{p1}$, $R_2=R_L+R_{p2}$とおいた。$R_S$などの素子の定数，角周波数$\omega$はすべて正の実数である。また結合係数$k$は$0 < k^2 < 1$を満たす値をとりうる。このとき，$P_N$は必ず$0 < P_N \leqq 1$の値をとる。この$P_N$を正規化電力という。$P_N$は
$$R_1,R_2,L_1,L_2,C_1,C_2,k,\omega$$
を変数とする８変数関数である。
負荷が受け取る平均電力を大きくしたい，つまりたとえば

- $0.9\leqq P_N\leqq 1$

となるような変数の値を知りたい。

### 現実的制約（部品・周波数など）

現実的には，

- 使用する電源は決まっていて内部抵抗をすでに求めている
- 電源が出すことのできる正弦波交流電圧の周波数$f$には限界がある
- 負荷の抵抗値は手元にあるものを直並列接続で作りたい
- コイルはすでに巻きおわっていて，それを利用したい
- コンデンサは在庫の中から選びたい

など，得たい電力以外の希望があるだろう。そこで解きたい問題は，$0.9\leqq P_N\leqq 1$だけでなく，次のような条件を満たす変数の値を知りたいということになる。

- $R_1=1.0$ $\Omega$
- $10.0$ kHz $\leqq f = \tfrac{\omega}{2\pi} \leqq$ $100.0$ kHz
- $R_2=10.0$ $\Omega$
- $L_1=140.0$ $\mu$ H
- $L_2=130.0$ $\mu$ H
- $1.0$ nF $\leqq C_1 \leqq$ $100.0$ nF
- $1.0$ nF $\leqq C_2 \leqq$ $100.0$ nF

### 探索

問題の答えを見つける最も単純な方法は，各変数について与えられた範囲から値を選び，関数に代入し，その結果が指定した範囲に入るかどうかを判定することである。この操作を多数回繰り返せば，条件を満たす解が得られる可能性がある。

しかし，いくら繰り返しても正解に到達できない場合もある。これは，そもそも解が存在しない場合と，繰り返し回数が不足している場合のいずれかである。どちらに該当するかを事前に判別することは，無線電力伝送の平均電力の式のような複雑な関数では一般に困難である。

そこで本プログラムでは，「変数の値を選び，代入し，判定する」という操作をあらかじめ定めた回数だけ実行し，その結果をもとに探索範囲の妥当性を判断する。正解が得られた場合は目的を達成したとし，得られなかった場合は範囲を再設定して再計算を行う。

この方法では繰り返し回数をできるだけ多くしたいが，解が存在しない場合も考慮すると，正解の有無にかかわらず短時間で結果を得ることが重要となる。そのため，本プログラムの実装には Go 言語を用いた。四則演算や条件判定といった基本的な処理の実行速度は C 言語と同等であり，体感的にはコンパイル済み Python の約 10 倍，通常の Python や Wolfram の約 100 倍の速度で動作する。

## コード

### ユーザーがコード中に記述（`config.go`）

- 関数の具体的定義式とその引数
- 各引数について，引数の値の範囲
- 各引数について，引数の値の範囲から値を線形的な分点で選ぶのか，対数的な分点で選ぶのかの別
- 関数の値の範囲
- 繰り返し回数
- 引数の値，関数の値のどれもが指定した範囲に入ったときの引数と関数の値（正解）
- 保存する正解の数
- 引数の値，関数の値のどれかが指定した範囲に入らなかったときの引数と関数の値（不正解）
- 保存する不正解の数
- エクセルファイルに保存したい場合はファイル名を指定
- tsv形式のファイルに保存したい場合はファイル名を指定（正解，不正解それぞれ）

範囲については以下で設定する。
```go
	params := []ParamSpec{
		{Name: "k", Min: 0.01, Max: 0.02, Scale: Linear},
		{Name: "f", Min: 10_000, Max: 100_000, Scale: Log}, // Hz
		{Name: "R1", Min: 1.0, Max: 1.0, Scale: Log},       // Ω
		{Name: "R2", Min: 10.0, Max: 10.0, Scale: Log},     // Ω
		{Name: "L1", Min: 140e-6, Max: 140e-6, Scale: Log}, // H
		{Name: "L2", Min: 80e-6, Max: 80e-6, Scale: Log},   // H
		{Name: "C1", Min: 1e-9, Max: 100e-9, Scale: Log},   // F
		{Name: "C2", Min: 1e-9, Max: 100e-9, Scale: Log},   // F
	}
    // 関数の値の範囲。計算結果がこの範囲に入っていれば正解，入っていなければ不正解
	yRange := Range{Min: 0.4, Max: 1.0}

	// 繰り返し回数（10_000_000 で数秒）
	maxIters := int64(10_000_000)

	// 保存する正解・不正解の数（多くするとファイルサイズ増）
	maxOKSave := 10
	maxNGSave := 10

	// 進行状況表示の更新間隔（多すぎると遅くなる）
	printEvery := int64(200_000)

	// 乱数 seed（実行時刻ベース）
	// seedを自分で決めてもよい。
	// 実行すると乱数発生に使用されたseedが表示されるので，そのときと同じ数字を使うと
	// 同じ乱数が発生するので，結果も同じになる。
	seed := time.Now().UnixNano()

	// xlsx 出力（空文字なら保存しない）
	// "" にすると保存はせず表示だけ
	xlsxFile := "result.xlsx"
	// tsv 出力（"" なら保存しない）
	okTSVFile := "ok.tsv"
	ngTSVFile := "ng.tsv"
```

### 出力（コンソール表示）（`output.go`）

- 保存した正解リスト
- 保存した不正解リスト
- Ctrl-Cで終了した場合はその時点における保存した正解リスト，不正解リスト
- エクセルファイル（ファイル名を指定した場合）
- tsv形式のファイル（ファイル名を指定した場合）

### 終了条件

- 繰り返し回数に到達
- Ctrl-C

### アルゴリズム

以下を終了条件を満たすまで繰り返す。進行状況確認用に正解数，不正解数カウンターを表示

- 線形分点指定の引数については，範囲中から線形的に一様乱数によって値を選ぶ
- 対数分点指定の引数については，範囲中から対数的に一様乱数によって値を選ぶ
- 選んだ引数の値で関数の値を計算
- 関数の値が範囲に入っていれば正解リストに追加。
- 関数の値が範囲に入っていなければ不正解リストに追加

### 実行方法

- `git`をインストールしておく
- `go`言語をインストールしておく
- コマンドプロンプトやpowershellで`git clone https://github.com/ichijohodaka/wpt-parameter-search2.git`
- `wpt-parameter-search2`フォルダに`cd`して，`go run .`
- 「ユーザー設定（ここから）」から「ユーザー設定（ここまで）」の間のコードを適宜書き換え
- ユーザーが関数を変更して使うことを想定しているので、buildせずにコードを直接修正して実行

## 使用例

### 実験装置の製作時

- そこそこ電力が出るような実験装置を作りたい。
- 電源は決まっている。
- コイルもある。

このような場合は、R1, R2, L1, L2のMinとMaxを決まっている値に一致させ、範囲を狭くしたほうが探索が成功しやすい。

```go
	params := []ParamSpec{
		{Name: "k", Min: 0.01, Max: 0.02, Scale: Linear},
		{Name: "f", Min: 10_000, Max: 100_000, Scale: Log}, // Hz
		{Name: "R1", Min: 1.0, Max: 1.0, Scale: Log},       // Ω
		{Name: "R2", Min: 10.0, Max: 10.0, Scale: Log},     // Ω
		{Name: "L1", Min: 140e-6, Max: 140e-6, Scale: Log}, // H
		{Name: "L2", Min: 80e-6, Max: 80e-6, Scale: Log},   // H
		{Name: "C1", Min: 1e-9, Max: 100e-9, Scale: Log},   // F
		{Name: "C2", Min: 1e-9, Max: 100e-9, Scale: Log},   // F
	}
```

### 電力が大きくなるようなパラメータの領域を視覚化

- R1, R2, L1, L2, C1, C2は決まった値を用いる。
- 正規化電力が0.8以上になるようなkとfの領域をみたい。

```go
	params := []ParamSpec{
		{Name: "k", Min: 0.1, Max: 0.8, Scale: Linear},
		{Name: "f", Min: 10_000, Max: 100_000, Scale: Log}, // Hz
		{Name: "R1", Min: 1.0, Max: 1.0, Scale: Log},       // Ω
		{Name: "R2", Min: 10.0, Max: 10.0, Scale: Log},     // Ω
		{Name: "L1", Min: 140e-6, Max: 140e-6, Scale: Log}, // H
		{Name: "L2", Min: 80e-6, Max: 80e-6, Scale: Log},   // H
		{Name: "C1", Min: 30e-9, Max: 100e-9, Scale: Log},  // F
		{Name: "C2", Min: 30e-9, Max: 100e-9, Scale: Log},  // F
	}

    yRange := Range{Min: 0.8, Max: 1.0}
```

この条件で実行したところ、次の結果を得た。

```bash
iter=    10000000 (100.00%)  OK_hits=       25443  NG_hits=     9974557
iter=    10000000 (100.00%)  OK_hits=       25443  NG_hits=     9974557
seed=1770969066026410100
yRange=[       0.8,          1]
iters=10000000  OK_hits=25443  NG_hits=9974557
OK_ratio=  0.002544  NG_ratio=    0.9975
```

OK_hitsの数がそこそこ大きいので領域をうまく表せそうである。そこでそのデータを保存する。データ数が大きくなりそうなので、むやみに保存すべきでない。ng.tsvのほうはいらないだろう。さきほどのseedを用いると同じ結果になる。OKの数もわかっているので、保存する数を一致させる。

```go
	// 繰り返し回数（10_000_000 で数秒）
	maxIters := int64(10_000_000)

	// 保存する正解・不正解の数（多くするとファイルサイズ増）
	maxOKSave := 25443
	maxNGSave := 10

	// 進行状況表示の更新間隔（多すぎると遅くなる）
	printEvery := int64(200_000)

	// 乱数 seed（実行時刻ベース）
	// seedを自分で決めてもよい。
	// 実行すると乱数発生に使用されたseedが表示されるので，そのときと同じ数字を使うと
	// 同じ乱数が発生するので，結果も同じになる。
	seed := time.Now().UnixNano()
	seed = 1770969066026410100

	// xlsx 出力（空文字なら保存しない）
	// "" にすると保存はせず表示だけ
	xlsxFile := ""
	// tsv 出力（"" なら保存しない）
	okTSVFile := "ok.tsv"
	ngTSVFile := ""
```

実行すると、3MBほどのok.tsvができた。










